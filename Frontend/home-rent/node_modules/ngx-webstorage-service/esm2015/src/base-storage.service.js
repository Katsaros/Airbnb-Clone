/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ProxyStorageService } from './proxy-storage.service';
/**
 * Base implementation for storage services.
 * @abstract
 * @template T
 */
export class BaseStorageService {
    /**
     * Creates a new `BaseStorageService` that uses the specified transcoder by default for read and write operations.
     *
     * @param {?} defaultTranscoder Transcoder which is to be used by default for storage read and write operations.
     */
    constructor(defaultTranscoder) {
        this.defaultTranscoder = defaultTranscoder;
    }
    /**
     * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored
     * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then
     * `undefined` will be returned.
     *
     * @param {?} key     Identifier of the entry whose value is to be retrieved.
     * @param {?=} decoder Decoder to use for converting the stored value to the desired return type.
     * @return {?} Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be
     *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.
     */
    get(key, decoder) {
        /** @type {?} */
        const value = this.getItem(key);
        return value !== undefined ? (decoder || this.defaultTranscoder).decode(value) : undefined;
    }
    /**
     * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given
     * value into a format that can be stored by the storage service's underlying storage.
     *
     * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of
     * the value will be the same. It, however, does not necessarily return the same reference.
     *
     * @param {?} key     Identifier of the entry which is to be created or updated.
     * @param {?} value   Value which is to be stored.
     * @param {?=} encoder Encoder used to convert the given value into a format that can be used for storage.
     * @return {?}
     */
    set(key, value, encoder) {
        this.setItem(key, (encoder || this.defaultTranscoder).encode(value));
    }
    /**
     * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service
     * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access
     * the same data.
     *
     * The default transcoder will not be changed for the storage service on which this function is invoked.
     *
     * @template X
     * @param {?} transcoder Transcoder that should be used by default for read and write operations by the new storage service.
     * @return {?} A new storage service that uses the specified transcoder by default.
     */
    withDefaultTranscoder(transcoder) {
        return new ProxyStorageService(transcoder, this);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    BaseStorageService.prototype.defaultTranscoder;
    /**
     * Checks whether an entry with the specified key exists in the storage.
     *
     * @abstract
     * @param {?} key Identifier of the entry for which its presence in the storage is to be checked.
     * @return {?} `true` if an entry with the specified key exists in the storage, `false` if not.
     */
    BaseStorageService.prototype.has = function (key) { };
    /**
     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.
     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.
     *
     * @abstract
     * @param {?} key Identifier of the entry which is to be removed.
     * @return {?}
     */
    BaseStorageService.prototype.remove = function (key) { };
    /**
     * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set
     * for key *x*.
     * @abstract
     * @return {?}
     */
    BaseStorageService.prototype.clear = function () { };
    /**
     * Performs the actual retrieval of a value from storage.
     *
     * @abstract
     * @protected
     * @param {?} key Identifier of the entry whose value is to be retrieved.
     * @return {?} The value that is stored for the specified entry or `undefined` if no entry exists for the specified key.
     */
    BaseStorageService.prototype.getItem = function (key) { };
    /**
     * Stores the provided value using specified key in the storage.
     *
     * @abstract
     * @protected
     * @param {?} key   Identifier of the entry for which the value is to be stored.
     * @param {?} value The value that is to be stored.
     * @return {?}
     */
    BaseStorageService.prototype.setItem = function (key, value) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1zdG9yYWdlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtd2Vic3RvcmFnZS1zZXJ2aWNlLyIsInNvdXJjZXMiOlsic3JjL2Jhc2Utc3RvcmFnZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7O0FBSzlELE1BQU0sT0FBZ0Isa0JBQWtCOzs7Ozs7SUFPcEMsWUFBNkIsaUJBQXVDO1FBQXZDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBc0I7SUFDcEUsQ0FBQzs7Ozs7Ozs7Ozs7SUFvQk0sR0FBRyxDQUFDLEdBQVcsRUFBRSxPQUE2Qjs7Y0FDM0MsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBRS9CLE9BQU8sS0FBSyxLQUFLLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDL0YsQ0FBQzs7Ozs7Ozs7Ozs7OztJQWFNLEdBQUcsQ0FBQyxHQUFXLEVBQUUsS0FBVSxFQUFFLE9BQTZCO1FBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7Ozs7Ozs7Ozs7OztJQTBCTSxxQkFBcUIsQ0FBSSxVQUFnQztRQUM1RCxPQUFPLElBQUksbUJBQW1CLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3JELENBQUM7Q0FrQko7Ozs7OztJQXRGZSwrQ0FBd0Q7Ozs7Ozs7O0lBU3BFLHNEQUEwQzs7Ozs7Ozs7O0lBdUMxQyx5REFBMEM7Ozs7Ozs7SUFNMUMscURBQThCOzs7Ozs7Ozs7SUFzQjlCLDBEQUE0RDs7Ozs7Ozs7OztJQVE1RCxpRUFBNkQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdG9yYWdlU2VydmljZSB9IGZyb20gJy4vc3RvcmFnZS5zZXJ2aWNlJztcbmltcG9ydCB7IFN0b3JhZ2VEZWNvZGVyLCBTdG9yYWdlRW5jb2RlciwgU3RvcmFnZVRyYW5zY29kZXIgfSBmcm9tICcuL3N0b3JhZ2UtdHJhbnNjb2Rlcic7XG5pbXBvcnQgeyBQcm94eVN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnLi9wcm94eS1zdG9yYWdlLnNlcnZpY2UnO1xuXG4vKipcbiAqIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHN0b3JhZ2Ugc2VydmljZXMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlU3RvcmFnZVNlcnZpY2U8VD4gaW1wbGVtZW50cyBTdG9yYWdlU2VydmljZTxUPiB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBCYXNlU3RvcmFnZVNlcnZpY2VgIHRoYXQgdXNlcyB0aGUgc3BlY2lmaWVkIHRyYW5zY29kZXIgYnkgZGVmYXVsdCBmb3IgcmVhZCBhbmQgd3JpdGUgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWZhdWx0VHJhbnNjb2RlciBUcmFuc2NvZGVyIHdoaWNoIGlzIHRvIGJlIHVzZWQgYnkgZGVmYXVsdCBmb3Igc3RvcmFnZSByZWFkIGFuZCB3cml0ZSBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdFRyYW5zY29kZXI6IFN0b3JhZ2VUcmFuc2NvZGVyPFQ+KSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZW50cnkgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgaW4gdGhlIHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBrZXkgSWRlbnRpZmllciBvZiB0aGUgZW50cnkgZm9yIHdoaWNoIGl0cyBwcmVzZW5jZSBpbiB0aGUgc3RvcmFnZSBpcyB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm5zICAgICBgdHJ1ZWAgaWYgYW4gZW50cnkgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgaW4gdGhlIHN0b3JhZ2UsIGBmYWxzZWAgaWYgbm90LlxuICAgICAqL1xuICAgIHB1YmxpYyBhYnN0cmFjdCBoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIHRoZSBlbnRyeSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS4gVGhlIGdpdmVuIGRlY29kZXIgaXMgdXNlZCB0byBjb252ZXJ0IHRoZSBzdG9yZWRcbiAgICAgKiB2YWx1ZSB0byB0aGUgZGVzaXJlZCB0eXBlLiBJZiBubyBlbnRyeSBmb3IgdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIGlmIHRoZSBkZWNvZGVyIGlzIHVuYWJsZSB0byBkZWNvZGUgdGhlIHN0b3JlZCB2YWx1ZSwgdGhlblxuICAgICAqIGB1bmRlZmluZWRgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBrZXkgICAgIElkZW50aWZpZXIgb2YgdGhlIGVudHJ5IHdob3NlIHZhbHVlIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcGFyYW0gICBkZWNvZGVyIERlY29kZXIgdG8gdXNlIGZvciBjb252ZXJ0aW5nIHRoZSBzdG9yZWQgdmFsdWUgdG8gdGhlIGRlc2lyZWQgcmV0dXJuIHR5cGUuXG4gICAgICogQHJldHVybnMgICAgICAgICBWYWx1ZSBvZiB0aGUgZW50cnkgdGhhdCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBzcGVjaWZpZWQga2V5LiBJbiBjYXNlIHRoZSBlbnRyeSBkb2VzIG5vdCBleGlzdCBvciBpZiBpdCBjYW5ub3QgYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGxvYWRlZCAoZHVlIHRvIGEgZGVjb2RpbmcgaXNzdWUpLCB0aGVuIGB1bmRlZmluZWRgIHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0KGtleTogc3RyaW5nLCBkZWNvZGVyPzogU3RvcmFnZURlY29kZXI8YW55Pik6IGFueSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRJdGVtKGtleSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyAoZGVjb2RlciB8fCB0aGlzLmRlZmF1bHRUcmFuc2NvZGVyKS5kZWNvZGUodmFsdWUpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgdXBkYXRlcyB0aGUgZW50cnkgaWRlbnRpZmllZCBieSB0aGUgc3BlY2lmaWVkIGtleSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gVGhlIHNwZWNpZmllZCBlbmNvZGVyIGlzIHVzZWQgdG8gY29udmVydCB0aGUgZ2l2ZW5cbiAgICAgKiB2YWx1ZSBpbnRvIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHN0b3JlZCBieSB0aGUgc3RvcmFnZSBzZXJ2aWNlJ3MgdW5kZXJseWluZyBzdG9yYWdlLlxuICAgICAqXG4gICAgICogU3RvcmluZyBhIHZhbHVlIGludG8gdGhlIHN0b3JhZ2Ugc2VydmljZSB3aWxsIGVuc3VyZSB0aGF0IGFuIGVxdWl2YWxlbnQgb2YgdGhlIHZhbHVlIGNhbiBiZSByZWFkIGJhY2ssIGkuZS4gdGhlIGRhdGEgYW5kIHN0cnVjdHVyZSBvZlxuICAgICAqIHRoZSB2YWx1ZSB3aWxsIGJlIHRoZSBzYW1lLiBJdCwgaG93ZXZlciwgZG9lcyBub3QgbmVjZXNzYXJpbHkgcmV0dXJuIHRoZSBzYW1lIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgICAgIElkZW50aWZpZXIgb2YgdGhlIGVudHJ5IHdoaWNoIGlzIHRvIGJlIGNyZWF0ZWQgb3IgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgICBWYWx1ZSB3aGljaCBpcyB0byBiZSBzdG9yZWQuXG4gICAgICogQHBhcmFtIGVuY29kZXIgRW5jb2RlciB1c2VkIHRvIGNvbnZlcnQgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBmb3JtYXQgdGhhdCBjYW4gYmUgdXNlZCBmb3Igc3RvcmFnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55LCBlbmNvZGVyPzogU3RvcmFnZUVuY29kZXI8YW55Pik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldEl0ZW0oa2V5LCAoZW5jb2RlciB8fCB0aGlzLmRlZmF1bHRUcmFuc2NvZGVyKS5lbmNvZGUodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBlbnRyeSB0aGF0IGlzIGlkZW50aWZpZWQgYnkgdGhlIHNwZWNpZmllZCBrZXkuIEF0dGVtcHRpbmcgdG8gcmVtb3ZlIGFuIGVudHJ5IGZvciBhbiB1bmtub3duIGtleSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgICAqIEF0dGVtcHRpbmcgdG8gcmV0cmlldmUgYW4gZW50cnkgdmlhIHRoZSBgZ2V0YCBtZXRob2QgYWZ0ZXIgaXQgaGFzIGJlZW4gcmVtb3ZlZCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgSWRlbnRpZmllciBvZiB0aGUgZW50cnkgd2hpY2ggaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgcmVtb3ZlKGtleTogc3RyaW5nKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc3RvcmFnZSBieSByZW1vdmluZyBhbGwgZW50cmllcy4gU3Vic2VxdWVudCBgZ2V0KHgpYCBjYWxscyBmb3IgYSBrZXkgKngqIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLCB1bnRpbCBhIG5ldyB2YWx1ZSBpcyBzZXRcbiAgICAgKiBmb3Iga2V5ICp4Ki5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgY2xlYXIoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3RvcmFnZSBzZXJ2aWNlIHRoYXQgdXNlcyB0aGUgc3BlY2lmaWVkIHRyYW5zY29kZXIgYnkgZGVmYXVsdCBmb3IgcmVhZCBhbmQgd3JpdGUgb3BlcmF0aW9ucy4gVGhlIG5ldyBzdG9yYWdlIHNlcnZpY2VcbiAgICAgKiB1c2VzIHRoZSBzdG9yYWdlIHNlcnZpY2Ugb24gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIGFzIHVuZGVybHlpbmcgc3RvcmFnZS4gQm90aCBzdG9yYWdlIHNlcnZpY2VzIHdpbGwgdGh1cyBiZSBhYmxlIHRvIGFjY2Vzc1xuICAgICAqIHRoZSBzYW1lIGRhdGEuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCB0cmFuc2NvZGVyIHdpbGwgbm90IGJlIGNoYW5nZWQgZm9yIHRoZSBzdG9yYWdlIHNlcnZpY2Ugb24gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgdHJhbnNjb2RlciBUcmFuc2NvZGVyIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgZGVmYXVsdCBmb3IgcmVhZCBhbmQgd3JpdGUgb3BlcmF0aW9ucyBieSB0aGUgbmV3IHN0b3JhZ2Ugc2VydmljZS5cbiAgICAgKiBAcmV0dXJucyAgICAgICAgICAgIEEgbmV3IHN0b3JhZ2Ugc2VydmljZSB0aGF0IHVzZXMgdGhlIHNwZWNpZmllZCB0cmFuc2NvZGVyIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgcHVibGljIHdpdGhEZWZhdWx0VHJhbnNjb2RlcjxYPih0cmFuc2NvZGVyOiBTdG9yYWdlVHJhbnNjb2RlcjxYPik6IFN0b3JhZ2VTZXJ2aWNlPFg+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eVN0b3JhZ2VTZXJ2aWNlKHRyYW5zY29kZXIsIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBhY3R1YWwgcmV0cmlldmFsIG9mIGEgdmFsdWUgZnJvbSBzdG9yYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtICAga2V5IElkZW50aWZpZXIgb2YgdGhlIGVudHJ5IHdob3NlIHZhbHVlIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJucyAgICAgVGhlIHZhbHVlIHRoYXQgaXMgc3RvcmVkIGZvciB0aGUgc3BlY2lmaWVkIGVudHJ5IG9yIGB1bmRlZmluZWRgIGlmIG5vIGVudHJ5IGV4aXN0cyBmb3IgdGhlIHNwZWNpZmllZCBrZXkuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHByb3ZpZGVkIHZhbHVlIHVzaW5nIHNwZWNpZmllZCBrZXkgaW4gdGhlIHN0b3JhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5ICAgSWRlbnRpZmllciBvZiB0aGUgZW50cnkgZm9yIHdoaWNoIHRoZSB2YWx1ZSBpcyB0byBiZSBzdG9yZWQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0aGF0IGlzIHRvIGJlIHN0b3JlZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG5cbn1cbiJdfQ==