/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Transcoder that encodes values as JSON strings.
 */
export class JsonStorageTranscoder {
    /**
     * @param {?} value
     * @return {?}
     */
    encode(value) {
        return JSON.stringify(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    decode(value) {
        try {
            return JSON.parse(value);
        }
        catch (error) {
            return undefined;
        }
    }
}
/**
 * Transcoder that encodes/decodes strings **as is**, i.e. values are not modified in any way.
 */
export class StringStorageTranscoder {
    /**
     * @param {?} value
     * @return {?}
     */
    encode(value) {
        return value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    decode(value) {
        return value;
    }
}
/**
 * Transcoder that encodes/decodes `boolean` values.
 */
export class BooleanStorageTranscoder {
    /**
     * @param {?} value
     * @return {?}
     */
    encode(value) {
        return value.toString();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    decode(value) {
        if (value === 'true') {
            return true;
        }
        if (value === 'false') {
            return false;
        }
        return undefined;
    }
}
/**
 * Transcoder that encodes/decodes `number` values.
 */
export class NumberStorageTranscoder {
    /**
     * @param {?} value
     * @return {?}
     */
    encode(value) {
        return value.toString();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    decode(value) {
        /** @type {?} */
        const parsedNumber = Number(value);
        return Number.isFinite(parsedNumber) ? parsedNumber : undefined;
    }
}
/**
 * Transcoder that encodes/decodes `Date` values to ISO strings.
 */
export class DateIsoStorageTranscoder {
    /**
     * @param {?} value
     * @return {?}
     */
    encode(value) {
        return value.toISOString();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    decode(value) {
        /** @type {?} */
        const timestamp = Date.parse(value);
        return isNaN(timestamp) ? undefined : new Date(timestamp);
    }
}
/**
 * Transcoder that encodes/decodes `Date` values to epoch timestamps.
 */
export class DateEpochStorageTranscoder {
    /**
     * @param {?} value
     * @return {?}
     */
    encode(value) {
        return value.valueOf().toString();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    decode(value) {
        /** @type {?} */
        const timestamp = parseInt(value, 10);
        return isNaN(timestamp) ? undefined : new Date(timestamp);
    }
}
/**
 * A set of storage transcoders.
 * @type {?}
 */
export const StorageTranscoders = {
    /**
     * Transcoder that encodes values as JSON strings.
     */
    JSON: (/** @type {?} */ (new JsonStorageTranscoder())),
    /**
     * Transcoder that encodes/decodes strings **as is**, i.e. values are not modified in any way.
     */
    STRING: (/** @type {?} */ (new StringStorageTranscoder())),
    /**
     * Transcoder that encodes/decodes `boolean` values.
     */
    BOOLEAN: (/** @type {?} */ (new BooleanStorageTranscoder())),
    /**
     * Transcoder that encodes/decodes `number` values.
     */
    NUMBER: (/** @type {?} */ (new NumberStorageTranscoder())),
    /**
     * Transcoder that encodes/decodes `Date` values into ISO strings.
     */
    DATE_ISO_STRING: (/** @type {?} */ (new DateIsoStorageTranscoder())),
    /**
     * Transcoder that encodes/decodes `Date` values into epoch timestamps.
     */
    DATE_EPOCH_TIME: (/** @type {?} */ (new DateEpochStorageTranscoder()))
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS10cmFuc2NvZGVycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC13ZWJzdG9yYWdlLXNlcnZpY2UvIiwic291cmNlcyI6WyJzcmMvc3RvcmFnZS10cmFuc2NvZGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0EsTUFBTSxPQUFPLHFCQUFxQjs7Ozs7SUFFdkIsTUFBTSxDQUFDLEtBQVU7UUFDcEIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pDLENBQUM7Ozs7O0lBRU0sTUFBTSxDQUFDLEtBQWE7UUFDdkIsSUFBSTtZQUNBLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM1QjtRQUFDLE9BQU8sS0FBSyxFQUFFO1lBQ1osT0FBTyxTQUFTLENBQUM7U0FDcEI7SUFDTCxDQUFDO0NBRUo7Ozs7QUFHRCxNQUFNLE9BQU8sdUJBQXVCOzs7OztJQUN6QixNQUFNLENBQUMsS0FBYTtRQUN2QixPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDOzs7OztJQUVNLE1BQU0sQ0FBQyxLQUFhO1FBQ3ZCLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7Q0FDSjs7OztBQUdELE1BQU0sT0FBTyx3QkFBd0I7Ozs7O0lBQzFCLE1BQU0sQ0FBQyxLQUFjO1FBQ3hCLE9BQU8sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzVCLENBQUM7Ozs7O0lBRU0sTUFBTSxDQUFDLEtBQWE7UUFDdkIsSUFBSSxLQUFLLEtBQUssTUFBTSxFQUFFO1lBQ2xCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLEtBQUssS0FBSyxPQUFPLEVBQUU7WUFDbkIsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNyQixDQUFDO0NBQ0o7Ozs7QUFHRCxNQUFNLE9BQU8sdUJBQXVCOzs7OztJQUN6QixNQUFNLENBQUMsS0FBYTtRQUN2QixPQUFPLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM1QixDQUFDOzs7OztJQUVNLE1BQU0sQ0FBQyxLQUFhOztjQUNqQixZQUFZLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUVsQyxPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ3BFLENBQUM7Q0FDSjs7OztBQUdELE1BQU0sT0FBTyx3QkFBd0I7Ozs7O0lBQzFCLE1BQU0sQ0FBQyxLQUFXO1FBQ3JCLE9BQU8sS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQy9CLENBQUM7Ozs7O0lBRU0sTUFBTSxDQUFDLEtBQWE7O2NBQ2pCLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUVuQyxPQUFPLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5RCxDQUFDO0NBQ0o7Ozs7QUFHRCxNQUFNLE9BQU8sMEJBQTBCOzs7OztJQUM1QixNQUFNLENBQUMsS0FBVztRQUNyQixPQUFPLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUN0QyxDQUFDOzs7OztJQUVNLE1BQU0sQ0FBQyxLQUFhOztjQUNqQixTQUFTLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7UUFFckMsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUQsQ0FBQztDQUNKOzs7OztBQUdELE1BQU0sT0FBTyxrQkFBa0IsR0FBRzs7OztJQUU5QixJQUFJLEVBQUUsbUJBQUEsSUFBSSxxQkFBcUIsRUFBRSxFQUEwQjs7OztJQUczRCxNQUFNLEVBQUUsbUJBQUEsSUFBSSx1QkFBdUIsRUFBRSxFQUE2Qjs7OztJQUdsRSxPQUFPLEVBQUUsbUJBQUEsSUFBSSx3QkFBd0IsRUFBRSxFQUE4Qjs7OztJQUdyRSxNQUFNLEVBQUUsbUJBQUEsSUFBSSx1QkFBdUIsRUFBRSxFQUE2Qjs7OztJQUdsRSxlQUFlLEVBQUUsbUJBQUEsSUFBSSx3QkFBd0IsRUFBRSxFQUEyQjs7OztJQUcxRSxlQUFlLEVBQUUsbUJBQUEsSUFBSSwwQkFBMEIsRUFBRSxFQUEyQjtDQUMvRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN0b3JhZ2VUcmFuc2NvZGVyIH0gZnJvbSAnLi9zdG9yYWdlLXRyYW5zY29kZXInO1xuXG4vKiogVHJhbnNjb2RlciB0aGF0IGVuY29kZXMgdmFsdWVzIGFzIEpTT04gc3RyaW5ncy4gKi9cbmV4cG9ydCBjbGFzcyBKc29uU3RvcmFnZVRyYW5zY29kZXIgaW1wbGVtZW50cyBTdG9yYWdlVHJhbnNjb2Rlcjxhbnk+IHtcblxuICAgIHB1YmxpYyBlbmNvZGUodmFsdWU6IGFueSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZSh2YWx1ZTogc3RyaW5nKTogYW55IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyoqIFRyYW5zY29kZXIgdGhhdCBlbmNvZGVzL2RlY29kZXMgc3RyaW5ncyAqKmFzIGlzKiosIGkuZS4gdmFsdWVzIGFyZSBub3QgbW9kaWZpZWQgaW4gYW55IHdheS4gKi9cbmV4cG9ydCBjbGFzcyBTdHJpbmdTdG9yYWdlVHJhbnNjb2RlciBpbXBsZW1lbnRzIFN0b3JhZ2VUcmFuc2NvZGVyPHN0cmluZz4ge1xuICAgIHB1YmxpYyBlbmNvZGUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG4vKiogVHJhbnNjb2RlciB0aGF0IGVuY29kZXMvZGVjb2RlcyBgYm9vbGVhbmAgdmFsdWVzLiAqL1xuZXhwb3J0IGNsYXNzIEJvb2xlYW5TdG9yYWdlVHJhbnNjb2RlciBpbXBsZW1lbnRzIFN0b3JhZ2VUcmFuc2NvZGVyPGJvb2xlYW4+IHtcbiAgICBwdWJsaWMgZW5jb2RlKHZhbHVlOiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZSh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG4vKiogVHJhbnNjb2RlciB0aGF0IGVuY29kZXMvZGVjb2RlcyBgbnVtYmVyYCB2YWx1ZXMuICovXG5leHBvcnQgY2xhc3MgTnVtYmVyU3RvcmFnZVRyYW5zY29kZXIgaW1wbGVtZW50cyBTdG9yYWdlVHJhbnNjb2RlcjxudW1iZXI+IHtcbiAgICBwdWJsaWMgZW5jb2RlKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBwYXJzZWROdW1iZXIgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUocGFyc2VkTnVtYmVyKSA/IHBhcnNlZE51bWJlciA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbi8qKiBUcmFuc2NvZGVyIHRoYXQgZW5jb2Rlcy9kZWNvZGVzIGBEYXRlYCB2YWx1ZXMgdG8gSVNPIHN0cmluZ3MuICovXG5leHBvcnQgY2xhc3MgRGF0ZUlzb1N0b3JhZ2VUcmFuc2NvZGVyIGltcGxlbWVudHMgU3RvcmFnZVRyYW5zY29kZXI8RGF0ZT4ge1xuICAgIHB1YmxpYyBlbmNvZGUodmFsdWU6IERhdGUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlKHZhbHVlOiBzdHJpbmcpOiBEYXRlIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGlzTmFOKHRpbWVzdGFtcCkgPyB1bmRlZmluZWQgOiBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICAgIH1cbn1cblxuLyoqIFRyYW5zY29kZXIgdGhhdCBlbmNvZGVzL2RlY29kZXMgYERhdGVgIHZhbHVlcyB0byBlcG9jaCB0aW1lc3RhbXBzLiAqL1xuZXhwb3J0IGNsYXNzIERhdGVFcG9jaFN0b3JhZ2VUcmFuc2NvZGVyIGltcGxlbWVudHMgU3RvcmFnZVRyYW5zY29kZXI8RGF0ZT4ge1xuICAgIHB1YmxpYyBlbmNvZGUodmFsdWU6IERhdGUpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWVPZigpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZSh2YWx1ZTogc3RyaW5nKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cbiAgICAgICAgcmV0dXJuIGlzTmFOKHRpbWVzdGFtcCkgPyB1bmRlZmluZWQgOiBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICAgIH1cbn1cblxuLyoqIEEgc2V0IG9mIHN0b3JhZ2UgdHJhbnNjb2RlcnMuICovXG5leHBvcnQgY29uc3QgU3RvcmFnZVRyYW5zY29kZXJzID0ge1xuICAgIC8qKiBUcmFuc2NvZGVyIHRoYXQgZW5jb2RlcyB2YWx1ZXMgYXMgSlNPTiBzdHJpbmdzLiAqL1xuICAgIEpTT046IG5ldyBKc29uU3RvcmFnZVRyYW5zY29kZXIoKSBhcyBTdG9yYWdlVHJhbnNjb2Rlcjxhbnk+LFxuXG4gICAgLyoqIFRyYW5zY29kZXIgdGhhdCBlbmNvZGVzL2RlY29kZXMgc3RyaW5ncyAqKmFzIGlzKiosIGkuZS4gdmFsdWVzIGFyZSBub3QgbW9kaWZpZWQgaW4gYW55IHdheS4gKi9cbiAgICBTVFJJTkc6IG5ldyBTdHJpbmdTdG9yYWdlVHJhbnNjb2RlcigpIGFzIFN0b3JhZ2VUcmFuc2NvZGVyPHN0cmluZz4sXG5cbiAgICAvKiogVHJhbnNjb2RlciB0aGF0IGVuY29kZXMvZGVjb2RlcyBgYm9vbGVhbmAgdmFsdWVzLiAqL1xuICAgIEJPT0xFQU46IG5ldyBCb29sZWFuU3RvcmFnZVRyYW5zY29kZXIoKSBhcyBTdG9yYWdlVHJhbnNjb2Rlcjxib29sZWFuPixcblxuICAgIC8qKiBUcmFuc2NvZGVyIHRoYXQgZW5jb2Rlcy9kZWNvZGVzIGBudW1iZXJgIHZhbHVlcy4gKi9cbiAgICBOVU1CRVI6IG5ldyBOdW1iZXJTdG9yYWdlVHJhbnNjb2RlcigpIGFzIFN0b3JhZ2VUcmFuc2NvZGVyPG51bWJlcj4sXG5cbiAgICAvKiogVHJhbnNjb2RlciB0aGF0IGVuY29kZXMvZGVjb2RlcyBgRGF0ZWAgdmFsdWVzIGludG8gSVNPIHN0cmluZ3MuICovXG4gICAgREFURV9JU09fU1RSSU5HOiBuZXcgRGF0ZUlzb1N0b3JhZ2VUcmFuc2NvZGVyKCkgYXMgU3RvcmFnZVRyYW5zY29kZXI8RGF0ZT4sXG5cbiAgICAvKiogVHJhbnNjb2RlciB0aGF0IGVuY29kZXMvZGVjb2RlcyBgRGF0ZWAgdmFsdWVzIGludG8gZXBvY2ggdGltZXN0YW1wcy4gKi9cbiAgICBEQVRFX0VQT0NIX1RJTUU6IG5ldyBEYXRlRXBvY2hTdG9yYWdlVHJhbnNjb2RlcigpIGFzIFN0b3JhZ2VUcmFuc2NvZGVyPERhdGU+XG59O1xuIl19