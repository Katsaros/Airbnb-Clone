/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * A storage service implementation that is used as a proxy for another storage service. This is used to create storage services with a
 * different default transcoder.
 * @template T
 */
export class ProxyStorageService {
    /**
     * Creates a new `ProxyStorageService` instance that uses the specified transcoder by default for read and write operations. Actual
     * read and writes are delegated to given storage service.
     *
     * @param {?} defaultTranscoder Transcoder which is to be used by default for storage read and write operations.
     * @param {?} subject           Storage service which should handle to actual storage of data.
     */
    constructor(defaultTranscoder, subject) {
        this.defaultTranscoder = defaultTranscoder;
        this.subject = subject;
    }
    /**
     * Checks whether an entry with the specified key exists in the storage.
     *
     * @param {?} key Identifier of the entry for which its presence in the storage is to be checked.
     * @return {?} `true` if an entry with the specified key exists in the storage, `false` if not.
     */
    has(key) {
        return this.subject.has(key);
    }
    /*
         * Retrieves the value stored for the entry that is associated with the specified key. The given decoder is used to convert the stored
         * value to the desired type. If no entry for the specified key exists or if the decoder is unable to decode the stored value, then
         * `undefined` will be returned.
         *
         * @param   key     Identifier of the entry whose value is to be retrieved.
         * @param   decoder Decoder to use for converting the stored value to the desired return type.
         * @returns         Value of the entry that is identified by the specified key. In case the entry does not exist or if it cannot be
         *                  loaded (due to a decoding issue), then `undefined` will be returned by this function.
         */
    /**
     * @param {?} key
     * @param {?=} decoder
     * @return {?}
     */
    get(key, decoder) {
        return this.subject.get(key, decoder || this.defaultTranscoder);
    }
    /**
     * Creates or updates the entry identified by the specified key with the given value. The specified encoder is used to convert the given
     * value into a format that can be stored by the storage service's underlying storage.
     *
     * Storing a value into the storage service will ensure that an equivalent of the value can be read back, i.e. the data and structure of
     * the value will be the same. It, however, does not necessarily return the same reference.
     *
     * @param {?} key     Identifier of the entry which is to be created or updated.
     * @param {?} value   Value which is to be stored.
     * @param {?=} encoder Encoder used to convert the given value into a format that can be used for storage.
     * @return {?}
     */
    set(key, value, encoder) {
        this.subject.set(key, value, encoder || this.defaultTranscoder);
    }
    /**
     * Removes the entry that is identified by the specified key. Attempting to remove an entry for an unknown key will have no effect.
     * Attempting to retrieve an entry via the `get` method after it has been removed will result in `undefined`.
     *
     * @param {?} key Identifier of the entry which is to be removed.
     * @return {?}
     */
    remove(key) {
        this.subject.remove(key);
    }
    /**
     * Clears the storage by removing all entries. Subsequent `get(x)` calls for a key *x* will return `undefined`, until a new value is set
     * for key *x*.
     * @return {?}
     */
    clear() {
        this.subject.clear();
    }
    /**
     * Creates a new storage service that uses the specified transcoder by default for read and write operations. The new storage service
     * uses the storage service on which this function is invoked as underlying storage. Both storage services will thus be able to access
     * the same data.
     *
     * The default transcoder will not be changed for the storage service on which this function is invoked.
     *
     * @template X
     * @param {?} transcoder Transcoder that should be used by default for read and write operations by the new storage service.
     * @return {?} A new storage service that uses the specified transcoder by default.
     */
    withDefaultTranscoder(transcoder) {
        return new ProxyStorageService(transcoder, this.subject);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ProxyStorageService.prototype.defaultTranscoder;
    /**
     * @type {?}
     * @private
     */
    ProxyStorageService.prototype.subject;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJveHktc3RvcmFnZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXdlYnN0b3JhZ2Utc2VydmljZS8iLCJzb3VyY2VzIjpbInNyYy9wcm94eS1zdG9yYWdlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBT0EsTUFBTSxPQUFPLG1CQUFtQjs7Ozs7Ozs7SUFTNUIsWUFDcUIsaUJBQXVDLEVBQ3ZDLE9BQXVCO1FBRHZCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBc0I7UUFDdkMsWUFBTyxHQUFQLE9BQU8sQ0FBZ0I7SUFDeEMsQ0FBQzs7Ozs7OztJQVFFLEdBQUcsQ0FBQyxHQUFXO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztJQVlNLEdBQUcsQ0FBQyxHQUFXLEVBQUUsT0FBNkI7UUFDakQsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsT0FBTyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7Ozs7Ozs7Ozs7Ozs7SUFhTSxHQUFHLENBQUMsR0FBVyxFQUFFLEtBQVUsRUFBRSxPQUE2QjtRQUM3RCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLE9BQU8sSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUNwRSxDQUFDOzs7Ozs7OztJQVFNLE1BQU0sQ0FBQyxHQUFXO1FBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzdCLENBQUM7Ozs7OztJQU1NLEtBQUs7UUFDUixJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ3pCLENBQUM7Ozs7Ozs7Ozs7OztJQVlNLHFCQUFxQixDQUFJLFVBQWdDO1FBQzVELE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzdELENBQUM7Q0FDSjs7Ozs7O0lBMUVPLGdEQUF3RDs7Ozs7SUFDeEQsc0NBQXdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICcuL3N0b3JhZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBTdG9yYWdlVHJhbnNjb2RlciwgU3RvcmFnZURlY29kZXIsIFN0b3JhZ2VFbmNvZGVyIH0gZnJvbSAnLi9zdG9yYWdlLXRyYW5zY29kZXInO1xuXG4vKipcbiAqIEEgc3RvcmFnZSBzZXJ2aWNlIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgdXNlZCBhcyBhIHByb3h5IGZvciBhbm90aGVyIHN0b3JhZ2Ugc2VydmljZS4gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBzdG9yYWdlIHNlcnZpY2VzIHdpdGggYVxuICogZGlmZmVyZW50IGRlZmF1bHQgdHJhbnNjb2Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFByb3h5U3RvcmFnZVNlcnZpY2U8VD4gaW1wbGVtZW50cyBTdG9yYWdlU2VydmljZTxUPiB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBQcm94eVN0b3JhZ2VTZXJ2aWNlYCBpbnN0YW5jZSB0aGF0IHVzZXMgdGhlIHNwZWNpZmllZCB0cmFuc2NvZGVyIGJ5IGRlZmF1bHQgZm9yIHJlYWQgYW5kIHdyaXRlIG9wZXJhdGlvbnMuIEFjdHVhbFxuICAgICAqIHJlYWQgYW5kIHdyaXRlcyBhcmUgZGVsZWdhdGVkIHRvIGdpdmVuIHN0b3JhZ2Ugc2VydmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWZhdWx0VHJhbnNjb2RlciBUcmFuc2NvZGVyIHdoaWNoIGlzIHRvIGJlIHVzZWQgYnkgZGVmYXVsdCBmb3Igc3RvcmFnZSByZWFkIGFuZCB3cml0ZSBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSBzdWJqZWN0ICAgICAgICAgICBTdG9yYWdlIHNlcnZpY2Ugd2hpY2ggc2hvdWxkIGhhbmRsZSB0byBhY3R1YWwgc3RvcmFnZSBvZiBkYXRhLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRUcmFuc2NvZGVyOiBTdG9yYWdlVHJhbnNjb2RlcjxUPixcbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBzdWJqZWN0OiBTdG9yYWdlU2VydmljZVxuICAgICkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbnRyeSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBpbiB0aGUgc3RvcmFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAgIGtleSBJZGVudGlmaWVyIG9mIHRoZSBlbnRyeSBmb3Igd2hpY2ggaXRzIHByZXNlbmNlIGluIHRoZSBzdG9yYWdlIGlzIHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybnMgICAgIGB0cnVlYCBpZiBhbiBlbnRyeSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBpbiB0aGUgc3RvcmFnZSwgYGZhbHNlYCBpZiBub3QuXG4gICAgICovXG4gICAgcHVibGljIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0LmhhcyhrZXkpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBzdG9yZWQgZm9yIHRoZSBlbnRyeSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS4gVGhlIGdpdmVuIGRlY29kZXIgaXMgdXNlZCB0byBjb252ZXJ0IHRoZSBzdG9yZWRcbiAgICAgKiB2YWx1ZSB0byB0aGUgZGVzaXJlZCB0eXBlLiBJZiBubyBlbnRyeSBmb3IgdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIGlmIHRoZSBkZWNvZGVyIGlzIHVuYWJsZSB0byBkZWNvZGUgdGhlIHN0b3JlZCB2YWx1ZSwgdGhlblxuICAgICAqIGB1bmRlZmluZWRgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICBrZXkgICAgIElkZW50aWZpZXIgb2YgdGhlIGVudHJ5IHdob3NlIHZhbHVlIGlzIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcGFyYW0gICBkZWNvZGVyIERlY29kZXIgdG8gdXNlIGZvciBjb252ZXJ0aW5nIHRoZSBzdG9yZWQgdmFsdWUgdG8gdGhlIGRlc2lyZWQgcmV0dXJuIHR5cGUuXG4gICAgICogQHJldHVybnMgICAgICAgICBWYWx1ZSBvZiB0aGUgZW50cnkgdGhhdCBpcyBpZGVudGlmaWVkIGJ5IHRoZSBzcGVjaWZpZWQga2V5LiBJbiBjYXNlIHRoZSBlbnRyeSBkb2VzIG5vdCBleGlzdCBvciBpZiBpdCBjYW5ub3QgYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGxvYWRlZCAoZHVlIHRvIGEgZGVjb2RpbmcgaXNzdWUpLCB0aGVuIGB1bmRlZmluZWRgIHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0KGtleTogc3RyaW5nLCBkZWNvZGVyPzogU3RvcmFnZURlY29kZXI8YW55Pik6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmplY3QuZ2V0KGtleSwgZGVjb2RlciB8fCB0aGlzLmRlZmF1bHRUcmFuc2NvZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHVwZGF0ZXMgdGhlIGVudHJ5IGlkZW50aWZpZWQgYnkgdGhlIHNwZWNpZmllZCBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuIFRoZSBzcGVjaWZpZWQgZW5jb2RlciBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlIGdpdmVuXG4gICAgICogdmFsdWUgaW50byBhIGZvcm1hdCB0aGF0IGNhbiBiZSBzdG9yZWQgYnkgdGhlIHN0b3JhZ2Ugc2VydmljZSdzIHVuZGVybHlpbmcgc3RvcmFnZS5cbiAgICAgKlxuICAgICAqIFN0b3JpbmcgYSB2YWx1ZSBpbnRvIHRoZSBzdG9yYWdlIHNlcnZpY2Ugd2lsbCBlbnN1cmUgdGhhdCBhbiBlcXVpdmFsZW50IG9mIHRoZSB2YWx1ZSBjYW4gYmUgcmVhZCBiYWNrLCBpLmUuIHRoZSBkYXRhIGFuZCBzdHJ1Y3R1cmUgb2ZcbiAgICAgKiB0aGUgdmFsdWUgd2lsbCBiZSB0aGUgc2FtZS4gSXQsIGhvd2V2ZXIsIGRvZXMgbm90IG5lY2Vzc2FyaWx5IHJldHVybiB0aGUgc2FtZSByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5ICAgICBJZGVudGlmaWVyIG9mIHRoZSBlbnRyeSB3aGljaCBpcyB0byBiZSBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHZhbHVlICAgVmFsdWUgd2hpY2ggaXMgdG8gYmUgc3RvcmVkLlxuICAgICAqIEBwYXJhbSBlbmNvZGVyIEVuY29kZXIgdXNlZCB0byBjb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgZm9ybWF0IHRoYXQgY2FuIGJlIHVzZWQgZm9yIHN0b3JhZ2UuXG4gICAgICovXG4gICAgcHVibGljIHNldChrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgZW5jb2Rlcj86IFN0b3JhZ2VFbmNvZGVyPGFueT4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0LnNldChrZXksIHZhbHVlLCBlbmNvZGVyIHx8IHRoaXMuZGVmYXVsdFRyYW5zY29kZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGVudHJ5IHRoYXQgaXMgaWRlbnRpZmllZCBieSB0aGUgc3BlY2lmaWVkIGtleS4gQXR0ZW1wdGluZyB0byByZW1vdmUgYW4gZW50cnkgZm9yIGFuIHVua25vd24ga2V5IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAgICogQXR0ZW1wdGluZyB0byByZXRyaWV2ZSBhbiBlbnRyeSB2aWEgdGhlIGBnZXRgIG1ldGhvZCBhZnRlciBpdCBoYXMgYmVlbiByZW1vdmVkIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBJZGVudGlmaWVyIG9mIHRoZSBlbnRyeSB3aGljaCBpcyB0byBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0LnJlbW92ZShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc3RvcmFnZSBieSByZW1vdmluZyBhbGwgZW50cmllcy4gU3Vic2VxdWVudCBgZ2V0KHgpYCBjYWxscyBmb3IgYSBrZXkgKngqIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLCB1bnRpbCBhIG5ldyB2YWx1ZSBpcyBzZXRcbiAgICAgKiBmb3Iga2V5ICp4Ki5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3ViamVjdC5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3RvcmFnZSBzZXJ2aWNlIHRoYXQgdXNlcyB0aGUgc3BlY2lmaWVkIHRyYW5zY29kZXIgYnkgZGVmYXVsdCBmb3IgcmVhZCBhbmQgd3JpdGUgb3BlcmF0aW9ucy4gVGhlIG5ldyBzdG9yYWdlIHNlcnZpY2VcbiAgICAgKiB1c2VzIHRoZSBzdG9yYWdlIHNlcnZpY2Ugb24gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkIGFzIHVuZGVybHlpbmcgc3RvcmFnZS4gQm90aCBzdG9yYWdlIHNlcnZpY2VzIHdpbGwgdGh1cyBiZSBhYmxlIHRvIGFjY2Vzc1xuICAgICAqIHRoZSBzYW1lIGRhdGEuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCB0cmFuc2NvZGVyIHdpbGwgbm90IGJlIGNoYW5nZWQgZm9yIHRoZSBzdG9yYWdlIHNlcnZpY2Ugb24gd2hpY2ggdGhpcyBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtICAgdHJhbnNjb2RlciBUcmFuc2NvZGVyIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgZGVmYXVsdCBmb3IgcmVhZCBhbmQgd3JpdGUgb3BlcmF0aW9ucyBieSB0aGUgbmV3IHN0b3JhZ2Ugc2VydmljZS5cbiAgICAgKiBAcmV0dXJucyAgICAgICAgICAgIEEgbmV3IHN0b3JhZ2Ugc2VydmljZSB0aGF0IHVzZXMgdGhlIHNwZWNpZmllZCB0cmFuc2NvZGVyIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgcHVibGljIHdpdGhEZWZhdWx0VHJhbnNjb2RlcjxYPih0cmFuc2NvZGVyOiBTdG9yYWdlVHJhbnNjb2RlcjxYPik6IFN0b3JhZ2VTZXJ2aWNlPFg+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eVN0b3JhZ2VTZXJ2aWNlKHRyYW5zY29kZXIsIHRoaXMuc3ViamVjdCk7XG4gICAgfVxufVxuIl19